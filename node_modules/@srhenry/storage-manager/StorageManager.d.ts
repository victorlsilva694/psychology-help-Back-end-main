/// <reference types="node" />
import fs from "fs";
import Stream from "stream";
import Path from "path";
import { IgnoreUnionType } from "./utils";
import { DirectoryList } from "./DirectoryList";
/** Read mode */
declare type ReadMode = "r";
/** Write mode */
declare type WriteMode = "w";
/** Read and write mode */
declare type DuplexMode = "rw";
/** File modes supported */
export declare type FileStreamMode = ReadMode | WriteMode | DuplexMode;
/** Stream options supported */
export declare type FileStreamOptions = Stream.ReadableOptions | Stream.WritableOptions | Stream.DuplexOptions;
/** Helper to infer Stream type from file mode */
declare type FileStreamType<T extends FileStreamMode> = T extends ReadMode ? Stream.Readable : T extends WriteMode ? Stream.Writable : T extends DuplexMode ? Stream.Duplex : never;
/** Helper to infer StreamOptions type from file mode */
declare type FileStreamOptionsType<T extends FileStreamMode> = T extends ReadMode ? Stream.ReadableOptions : T extends WriteMode ? Stream.WritableOptions : T extends DuplexMode ? Stream.DuplexOptions : never;
/** fs Stream options supported in read mode */
declare type NodeJS_fsReadOptions = IgnoreUnionType<Parameters<typeof fs.createReadStream>[1], string>;
/** fs Stream options supported in write mode */
declare type NodeJS_fsWriteOptions = IgnoreUnionType<Parameters<typeof fs.createReadStream>[1], string>;
/** fs Stream options supported in duplex mode */
declare type NodeJS_fsDuplexOptions = {
    readOptions?: IgnoreUnionType<NodeJS_fsReadOptions, string> | null;
    writeOptions?: IgnoreUnionType<NodeJS_fsWriteOptions, string> | null;
};
/** Helper to infer fs stream options from file mode */
declare type NodeJS_fsOptionsType<T extends FileStreamMode> = T extends ReadMode ? NodeJS_fsReadOptions : T extends WriteMode ? NodeJS_fsWriteOptions : T extends DuplexMode ? NodeJS_fsDuplexOptions : never;
/** Supported input types for underlying API (node/fs) */
export declare type ValidInput = string | Buffer;
/** Supported input types for {@link StorageManager} filesystem wrapper */
export declare type Input = ValidInput | number | object;
/**
 * Wrapper to sanitize input of filesystem input wrappers.
 * @param input Input data to sanitize.
 * @returns a string or buffer representing the input data
 *
 * @since 1.2.0
 */
export declare function sanitizeInput(input: Buffer): Buffer;
export declare function sanitizeInput(input: string): string;
export declare function sanitizeInput(input: object): string;
export declare function sanitizeInput<T = unknown>(input: T[]): string;
export declare function sanitizeInput<T = unknown>(input: T): string;
/**
 * A filesystem wrapper class
 */
export declare class StorageManager {
    /** @internal */
    private constructor();
    static readonly constants: typeof fs.constants;
    static readonly path: Path.PlatformPath;
    /**
     * Wrapper to write in a given filename.
     * @param path Path to write file.
     * @param value Plain string to insert into file, or Buffer instance, or serializable (as JSON) object.
     * @param charset Optional charset of data. Default is "utf-8".
     */
    static put(path: string, value: Input, charset?: BufferEncoding): Promise<boolean>;
    /**
     * Wrapper to write in a given filename.
     * @param path Path to write file.
     * @param values You can provide an async iterable object to write on demand or a synchronous one to group inputs before write.
     * @param charset Optional charset of data. Default is "utf-8".
     */
    static putStreamed(path: string, values: AsyncIterable<Input>, charset?: BufferEncoding): Promise<void>;
    static putStreamed(path: string, values: Iterable<Input>, charset?: BufferEncoding): Promise<void>;
    static putStreamed(path: string, value: Input, charset?: BufferEncoding): Promise<void>;
    /**
     * Wrapper to append file with data.
     * @param path Path to write file.
     * @param value Plain string to append to file, or Buffer instance, or serializable (as JSON) object.
     * @param charset Optional charset of data. Default is "utf-8".
     */
    static append(path: string, value: Input, charset?: BufferEncoding): Promise<boolean>;
    /**
     * Wrapper to append file with data.
     * @param path Path to write file.
     * @param values You can provide an async iterable object to write on demand or a synchronous one to group inputs before write.
     * @param charset Optional charset of data. Default is "utf-8".
     */
    static appendStreamed(path: string, values: AsyncIterable<Input>, charset?: BufferEncoding): Promise<void>;
    static appendStreamed(path: string, values: Iterable<Input>, charset?: BufferEncoding): Promise<void>;
    static appendStreamed(path: string, value: Input, charset?: BufferEncoding): Promise<void>;
    /**
     * Wrapper to read file (load all data in string, intended for small files like config. files).
     * @param path Path to read file.
     * @param encoding Optional encoding of string. Default is "utf-8".
     * @returns The string content of the file.
     */
    static get(path: string, encoding?: BufferEncoding): Promise<string>;
    /**
     * Wrapper to read file (load all data into array of buffers, intended for small binary files).
     * @param path Path to read file.
     * @returns The array with the binary buffers streamed of the file.
     */
    static getAsBuffers(path: string): Promise<Buffer[]>;
    /**
     * Wrapper to read file (load all data into a single buffer, intended for small binary files).
     * @param path Path to read file.
     * @returns The array with the binary buffers streamed of the file.
     */
    static getAsBuffer(path: string): Promise<Buffer>;
    /**
     * Wrapper to read file as JSON (load all data into a single buffer, intended for small binary files).
     * @param path Path to read JSON file (be careful to do not load huge JSONs, as it will load entire JSON file in string before parsing).
     * @param encoding file encoding to parse, default is "utf-8".
     * @param reviver A function that transforms the results. This function is called for each member of the object.
     * If a member contains nested objects, the nested objects are transformed before the parent object is.
     * @since 1.2.0
     */
    static getAsJSON(path: string, encoding?: BufferEncoding, reviver?: (this: any, key: string, value: any) => any): Promise<unknown>;
    /**
     * Wrapper to rename a file, or directory.
     * @param path Current path.
     * @param renameTo New name to file or directory.
     *
     * @since 1.4.0
     */
    static rename(path: string, renameTo: string): Promise<void>;
    /**
     * Wrapper to move a file, or directory.
     * @param from Current path.
     * @param to New path.
     * @param as Optional renaming.
     *
     * @since 1.4.0
     */
    static move(from: string, to: string, as?: string): Promise<void>;
    /**
     * Wrapper to copy a file or a directory to a given directory.
     * @param from Path to a file or directory.
     * @param to Path of new directory to copy (input will be put inside this path).
     * @param as Optional new name of file or directory.
     *
     * @since 1.4.0
     */
    static copy(from: string, to: string, as?: string): Promise<void>;
    /**
     * Create a readable stream of file at given path.
     * @param path Path to file
     * @param options Optional {@link Stream.ReadableOptions *node:stream.ReadableOptions*} object to customize stream
     * @param fsOptions Optional settings for underlying fs stream.
     *
     * @returns Readable stream object of file
     */
    static readStream(path: string, options?: Stream.ReadableOptions | null, fsOptions?: NodeJS_fsReadOptions | null): Stream.Readable;
    /**
     * Create a writable stream of file at given path.
     * @param path Path to file
     * @param options Optional {@link Stream.WritableOptions *node:stream.WritableOptions*} object to customize stream
     * @param fsOptions Optional settings for underlying fs stream.
     *
     * @returns Writable stream object of file
     */
    static writeStream(path: string, options?: Stream.WritableOptions | null, fsOptions?: NodeJS_fsWriteOptions | null): Stream.Writable;
    /**
     * Create a Duplex (both Readable and Writable) stream of file at given path.
     * @param path Path to file
     * @param options Optional {@link Stream.DuplexOptions *node:stream.DuplexOptions*} object to customize stream
     * @param fsOptions Optional settings for underlying fs stream.
     *
     * @returns Duplex stream object of file
     */
    static duplexStream(path: string, options?: Stream.DuplexOptions | null, readOptions?: NodeJS_fsReadOptions | null, writeOptions?: NodeJS_fsWriteOptions | null): Stream.Duplex;
    /**
     * Create a stream of file at given path.
     * @param path Path to file
     * @param mode file stream mode, defaults 'rw'
     * @param options Optional {@link Stream.StreamOptions *node:stream.StreamOptions*} object to customize stream
     * @param fsOptions Optional *node:fs.StreamOptions* object to customize stream
     *
     * @returns Stream object of file
     */
    static fileStream(path: string): Stream.Duplex;
    static fileStream(path: string, mode: ReadMode, options?: FileStreamOptionsType<typeof mode> | null, fsOptions?: NodeJS_fsOptionsType<typeof mode> | null): FileStreamType<typeof mode>;
    static fileStream(path: string, mode: WriteMode, options?: FileStreamOptionsType<typeof mode> | null, fsOptions?: NodeJS_fsOptionsType<typeof mode> | null): FileStreamType<typeof mode>;
    static fileStream(path: string, mode: DuplexMode, options?: FileStreamOptionsType<typeof mode> | null, fsOptions?: NodeJS_fsOptionsType<typeof mode> | null): FileStreamType<typeof mode>;
    static stream: typeof StorageManager.fileStream;
    /**
     * Wrapper to check if a path already exists in filesystem.
     * @param path Path to check avaiability.
     *
     * @returns A promise of existance check.
     */
    static exists(path: string): Promise<boolean>;
    /**
     * Wrapper to check if a path already exists in filesystem.
     * @param path Path to check avaiability.
     * @param mode Optional access mode flags to check avaiability (see: {@link fs.constants NodeJS.fs.constants}).
     *
     * @returns A promise of existance check.
     */
    static exists(path: string, mode: number): Promise<boolean>;
    static exists(path1: string, path2: string): Promise<boolean>;
    static exists(path1: string, path2: string, mode: number): Promise<boolean>;
    static exists(path1: string, path2: string, path3: string): Promise<boolean>;
    static exists(path1: string, path2: string, path3: string, mode: number): Promise<boolean>;
    static exists(path1: string, path2: string, path3: string, path4: string): Promise<boolean>;
    static exists(path1: string, path2: string, path3: string, path4: string, mode: number): Promise<boolean>;
    /**
     * Wrapper to check if a path already exists in filesystem.
     * @param paths paths to check in a row
     *
     * @returns A promise of existance check.
     */
    static exists(...paths: string[]): Promise<boolean>;
    static exists(...args: (string | number)[]): Promise<boolean>;
    /**
     * Wrapper to check if a path already exists in filesystem.
     * @param path Path to check avaiability.
     *
     * @returns A promise of existance check.
     */
    private static _exists;
    /**
     * Wrapper to retrieve stats of a given path
     * @param path Path to retrieve stats.
     * @since 1.4.0
     */
    static stats(path: string): Promise<fs.Stats>;
    /**
     * Wrapper to check if a path does not exist in filesystem. Is the oposite of {@link StorageManager.exists exists()} method.
     * @param path Path to check unavaiability.
     * @returns A promise of non-existance check.
     */
    static doesntExist(path: string): Promise<boolean>;
    /**
     * Wrapper to check if a path does not exist in filesystem. Is the oposite of {@link StorageManager.exists exists()} method.
     * @param path Path to check unavaiability.
     * @param mode Optional access mode flags to check unavaiability (see: {@link fs.constants NodeJS.fs.constants}).
     *
     * @returns A promise of non-existance check.
     */
    static doesntExist(path: string, mode: number): Promise<boolean>;
    static doesntExist(path1: string, path2: string): Promise<boolean>;
    static doesntExist(path1: string, path2: string, mode: number): Promise<boolean>;
    static doesntExist(path1: string, path2: string, path3: string): Promise<boolean>;
    static doesntExist(path1: string, path2: string, path3: string, mode: number): Promise<boolean>;
    static doesntExist(path1: string, path2: string, path3: string, path4: string): Promise<boolean>;
    static doesntExist(path1: string, path2: string, path3: string, path4: string, mode: number): Promise<boolean>;
    /**
    * Wrapper to check if a path does not exist in filesystem. Is the oposite of {@link StorageManager.exists exists()} method.
    * @param paths Paths to check in a row.
    *
    * @returns A promise of non-existance check.
    */
    static doesntExist(...paths: string[]): Promise<boolean>;
    static doesntExist(...args: (string | number)[]): Promise<boolean>;
    /** Checks if given path corresponds to a file */
    static isFile(path: string): Promise<boolean>;
    /** Checks if given path corresponds to a directory */
    static isDirectory(path: string): Promise<boolean>;
    /**
     * Wrapper to list directory contents
     * @param path Path to list
     * @param recursive Optional flag to list recursively
     */
    static listDirectory(path: string): Promise<string[]>;
    static listDirectory(path: string, recursive: false): Promise<string[]>;
    static listDirectory(path: string, recursive: true): Promise<DirectoryList>;
    /**
     * Wrapper to check if a path already exists in filesystem.
     * @param path Path to check avaiability.
     * @param cb Optional callback to run after async check.
     * @returns A promise of existance check.
     *
     * @deprecated @see {@link StorageManager.exists StorageManager.exists()}
     */
    static checkExist(path: string, cb?: (exists?: (boolean | PromiseLike<boolean> | undefined)) => any): Promise<boolean>;
    /**
     * Wrapper to write files asynchronously in filesystem.
     * @param filePath Path of the file to write in filesystem (overrides if already exists).
     * @param f File data, as ArrayBuffer or UInt8Array.
     * @param encoding Optional encoding of data, default binary.
     *
     * @deprecated @see {@link StorageManager.put StorageManager.put()},
     *  {@link StorageManager.putStreamed StorageManager.putStreamed()},
     *  {@link StorageManager.append StorageManager.append()},
     *  {@link StorageManager.appendStreamed StorageManager.appendStreamed()},
     */
    static writeStorage(filePath: string, f: ArrayBuffer | SharedArrayBuffer | Uint8Array, encoding?: BufferEncoding): Promise<void>;
    /**
     * Wrapper function to directory creation in filesystem (recursive or not).
     * @param path Path to search in filesystem.
     * @param options Filesystem options for mkdir operation.
     * @param cb Optional callback for mkdir async operation.
     * @returns A promise of mkdir operation.
     */
    static mkdir(path: string, options?: fs.MakeDirectoryOptions, cb?: (err: NodeJS.ErrnoException | null, path?: string) => null): Promise<NodeJS.ErrnoException | null>;
    /**
     *
     * @param filePath File path to write in filesystem (if parent directory does not exist, create before write the file).
     * @param data File data as ArrayBuffer.
     * @param chunkSize Chunk size of file.
     * @param cb Optional callback called when write operation is finished.
     * @returns A promise of the write operation.
     *
     * @deprecated @see {@link StorageManager.writeStream StorageManager.writeStream()}
     */
    static writeFileStream(filePath: string, data: ArrayBuffer, chunkSize?: number, cb?: (err?: Error | null) => void): Promise<boolean>;
    /**
     * Reads given file asynchronously on-demand and pipe out to given writable stream
     * @deprecated Obsolete and unsafe code using `Stream.pipe(stream: Stream.Writable)`. Prefer `Stream.pipeline(...streams: Stream[, cb: err => void])` implementation at `StorageManager.readFileStream(...)`
     * @param filePath path to the file in default storage
     * @param out writable stream to output retrieved data
     *
     * @deprecated @see {@link StorageManager.readStream StorageManager.readStream()}
     */
    static readStorage(filePath: string, out: Stream.Writable): Promise<void>;
    /**
     * Assynchronously reads given file at default storage. Supports Callback syntax and Promise syntax.
     * @param filePath path to the file in default storage.
     * @param cb optional callback to handle output and error. If not provided it resolve as a Promise
     *
     * @deprecated @see {@link StorageManager.getAsBuffers StorageManager.getAsBuffers()}
     */
    static getFileContents(filePath: string, cb?: (err: Error | null | undefined, arrayBuffer?: Array<Buffer>) => void): Promise<Buffer[]>;
    /**
     * Creates an Writable stream to transform/process chunk data from a file, piping'em, and returns the writed stream.
     *
     * @deprecated @see {@link StorageManager.readStream StorageManager.readStream()}
     *
     * @param filePath path to the file in default storage.
     * @param opts options to setup the write stream.
     * @param cb optional callback to error handling (default `console.error` output stream).
     */
    static readFileStream(filePath: string, opts?: Stream.WritableOptions | Stream.Writable, cb?: (err?: Error | null) => void): Stream.Writable;
    /**
     * Wrapper of delete operation in filesystem.
     * @param filePath A path to unlink or delete from filesystem.
     * @param callback Optional callback called after delete operation is finished.
     * @returns A promise of the delete operation.
     */
    static deleteFromStorage(filePath: string, callback?: (err: NodeJS.ErrnoException | null) => void | any): Promise<void>;
    /**
     * Wrapper of delete operation in filesystem.
     * @param filePath A path to unlink or delete from filesystem.
     * @returns A promise of the delete operation.
     */
    static delete: typeof StorageManager.deleteFromStorage;
    /**
     * Wrapper for opening attempts to a path, be file or directory.
     * @param path Path to open a file or list directory.
     * @param ifFile Optional callback called if path leads to a file.
     * @param ifDir Optional callback called if path leads to a directory.
     * @param encoding Optional encoding for files, default utf-8.
     *
     * @deprecated @see {@link StorageManager.stats StorageManager.stats()}
     */
    static openFileOrDirectory(path: string, ifFile?: (err: NodeJS.ErrnoException | null, data: string) => void, ifDir?: (err: NodeJS.ErrnoException | null, files: string[]) => void, encoding?: BufferEncoding): Promise<void>;
}
export default StorageManager;
