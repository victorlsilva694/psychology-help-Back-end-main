"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageManager = exports.sanitizeInput = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const stream_1 = __importDefault(require("stream"));
const path_1 = __importStar(require("path"));
const utils_1 = require("./utils");
const semver_1 = require("semver");
const DirectoryList_1 = require("./DirectoryList");
function sanitizeInput(input) {
    if (Buffer.isBuffer(input) || typeof input === "string")
        return input;
    else if (Array.isArray(input) || typeof input === "object")
        return JSON.stringify(input);
    else if ('toString' in input)
        return input.toString();
    else
        return `${input}`;
}
exports.sanitizeInput = sanitizeInput;
/**
 * A filesystem wrapper class
 */
class StorageManager {
    /** @internal */
    constructor() { }
    /**
     * Wrapper to write in a given filename.
     * @param path Path to write file.
     * @param value Plain string to insert into file, or Buffer instance, or serializable (as JSON) object.
     * @param charset Optional charset of data. Default is "utf-8".
     */
    static put(path, value, charset = "utf-8") {
        return __awaiter(this, void 0, void 0, function* () {
            if (path.split("/").length > 1)
                yield StorageManager.mkdir((0, path_1.dirname)(path), { recursive: true });
            return new Promise((resolve, reject) => {
                try {
                    const stream = StorageManager.fileStream(path, "w");
                    stream.write(sanitizeInput(value), charset, err => {
                        stream.end();
                        if (!!err)
                            reject(err);
                        else
                            resolve(true);
                    });
                }
                catch (err) {
                    reject(err);
                }
            });
        });
    }
    static putStreamed(path, values, charset = "utf-8") {
        var values_1, values_1_1;
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (path.split("/").length > 1)
                yield StorageManager.mkdir((0, path_1.dirname)(path), { recursive: true });
            const writeFactory = (path, encoding) => {
                const ws = StorageManager.fileStream(path, "w");
                return {
                    stream: ws,
                    write: (input) => new Promise((resolve, reject) => {
                        ws.write(sanitizeInput(input), encoding, err => !!err ? reject(err) : resolve(true));
                    })
                };
            };
            if ((0, utils_1.isIterable)(values)) {
                const { stream, write } = writeFactory(path, charset);
                for (const chunk of values)
                    yield write(chunk);
                stream.end();
            }
            else if ((0, utils_1.isAsyncIterable)(values)) {
                const { stream, write } = writeFactory(path, charset);
                try {
                    for (values_1 = __asyncValues(values); values_1_1 = yield values_1.next(), !values_1_1.done;) {
                        const chunk = values_1_1.value;
                        yield write(chunk);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (values_1_1 && !values_1_1.done && (_a = values_1.return)) yield _a.call(values_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                stream.end();
            }
            else {
                const { stream, write } = writeFactory(path, charset);
                yield write(values);
                stream.end();
            }
        });
    }
    /**
     * Wrapper to append file with data.
     * @param path Path to write file.
     * @param value Plain string to append to file, or Buffer instance, or serializable (as JSON) object.
     * @param charset Optional charset of data. Default is "utf-8".
     */
    static append(path, value, charset = "utf-8") {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield StorageManager.exists(path)) {
                return new Promise((resolve, reject) => {
                    const chunk = Buffer.isBuffer(value) ? value : Buffer.from(sanitizeInput(value), charset);
                    fs_1.default.appendFile(path, chunk, err => {
                        if (!!err)
                            reject(err);
                        else
                            resolve(true);
                    });
                });
            }
            else
                return StorageManager.put(path, value, charset);
        });
    }
    static appendStreamed(path, values, charset = "utf-8") {
        var values_2, values_2_1, values_3, values_3_1;
        var e_2, _a, e_3, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (yield StorageManager.exists(path)) {
                try {
                    for (values_2 = __asyncValues(values); values_2_1 = yield values_2.next(), !values_2_1.done;) {
                        const chunk = values_2_1.value;
                        yield StorageManager.append(path, chunk, charset);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (values_2_1 && !values_2_1.done && (_a = values_2.return)) yield _a.call(values_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                const writeFactory = (path, encoding) => {
                    const ws = StorageManager.fileStream(path, "w", null, { flags: "a" });
                    return {
                        stream: ws,
                        write: (input) => new Promise((resolve, reject) => {
                            ws.write(sanitizeInput(input), encoding, err => !!err ? reject(err) : resolve(true));
                        })
                    };
                };
                if ((0, utils_1.isIterable)(values)) {
                    const { stream, write } = writeFactory(path, charset);
                    for (const chunk of values)
                        yield write(chunk);
                    stream.end();
                }
                else if ((0, utils_1.isAsyncIterable)(values)) {
                    const { stream, write } = writeFactory(path, charset);
                    try {
                        for (values_3 = __asyncValues(values); values_3_1 = yield values_3.next(), !values_3_1.done;) {
                            const chunk = values_3_1.value;
                            yield write(chunk);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (values_3_1 && !values_3_1.done && (_b = values_3.return)) yield _b.call(values_3);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    stream.end();
                }
                else {
                    const { stream, write } = writeFactory(path, charset);
                    yield write(values);
                    stream.end();
                }
            }
            else
                return StorageManager.putStreamed(path, values, charset);
        });
    }
    /**
     * Wrapper to read file (load all data in string, intended for small files like config. files).
     * @param path Path to read file.
     * @param encoding Optional encoding of string. Default is "utf-8".
     * @returns The string content of the file.
     */
    static get(path, encoding = "utf-8") {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                StorageManager.getAsBuffer(path)
                    .then(buffer => resolve(buffer.toString(encoding)))
                    .catch(reject);
            });
        });
    }
    /**
     * Wrapper to read file (load all data into array of buffers, intended for small binary files).
     * @param path Path to read file.
     * @returns The array with the binary buffers streamed of the file.
     */
    static getAsBuffers(path) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            if (yield StorageManager.exists(path)) {
                const arraybuffer = new Array();
                const readStream = StorageManager.fileStream(path, "r");
                readStream.on('error', reject);
                readStream.on('data', chunk => {
                    if (Buffer.isBuffer(chunk))
                        arraybuffer.push(chunk);
                    else
                        arraybuffer.push(Buffer.from(chunk));
                });
                readStream.on('close', () => resolve(arraybuffer));
            }
            else
                reject(null);
        }));
    }
    /**
     * Wrapper to read file (load all data into a single buffer, intended for small binary files).
     * @param path Path to read file.
     * @returns The array with the binary buffers streamed of the file.
     */
    static getAsBuffer(path) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                resolve(Buffer.concat(yield StorageManager.getAsBuffers(path)));
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Wrapper to read file as JSON (load all data into a single buffer, intended for small binary files).
     * @param path Path to read JSON file (be careful to do not load huge JSONs, as it will load entire JSON file in string before parsing).
     * @param encoding file encoding to parse, default is "utf-8".
     * @param reviver A function that transforms the results. This function is called for each member of the object.
     * If a member contains nested objects, the nested objects are transformed before the parent object is.
     * @since 1.2.0
     */
    static getAsJSON(path, encoding = "utf8", reviver) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    resolve(JSON.parse(yield StorageManager.get(path, encoding), reviver));
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
     * Wrapper to rename a file, or directory.
     * @param path Current path.
     * @param renameTo New name to file or directory.
     *
     * @since 1.4.0
     */
    static rename(path, renameTo) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let dest = (0, path_1.dirname)(renameTo);
                if (dest === ".")
                    dest = (0, path_1.join)((0, path_1.dirname)(path));
                const to = (0, path_1.join)(dest, (0, path_1.basename)(renameTo));
                fs_1.default.rename(path, to, err => {
                    if (err)
                        reject(err);
                    else
                        resolve();
                });
            });
        });
    }
    /**
     * Wrapper to move a file, or directory.
     * @param from Current path.
     * @param to New path.
     * @param as Optional renaming.
     *
     * @since 1.4.0
     */
    static move(from, to, as) {
        return __awaiter(this, void 0, void 0, function* () {
            return StorageManager.rename(from, (0, path_1.join)(to, as !== null && as !== void 0 ? as : (0, path_1.basename)(from)));
        });
    }
    /**
     * Wrapper to copy a file or a directory to a given directory.
     * @param from Path to a file or directory.
     * @param to Path of new directory to copy (input will be put inside this path).
     * @param as Optional new name of file or directory.
     *
     * @since 1.4.0
     */
    static copy(from, to, as) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const stats = yield StorageManager.stats(from)
                    .catch(err => resolve(err));
                if (stats) {
                    const dest = (0, path_1.join)(to, as !== null && as !== void 0 ? as : (0, path_1.basename)(from));
                    if (stats.isFile()) {
                        yield StorageManager.mkdir(to, { recursive: true });
                        fs_1.default.copyFile(from, dest, err => {
                            if (err)
                                reject(err);
                            else
                                resolve();
                        });
                    }
                    else if (stats.isDirectory()) {
                        yield StorageManager.mkdir(dest, { recursive: true });
                        const dir = yield StorageManager.listDirectory(from, true);
                        const files = Array.from(dir)
                            .filter((file) => typeof file === "string");
                        const innerDirs = Array.from(dir)
                            .filter((file) => file instanceof DirectoryList_1.DirectoryList);
                        for (const file of files)
                            yield StorageManager.copy((0, path_1.join)(from, file), dest);
                        for (const { name } of innerDirs)
                            yield StorageManager.copy((0, path_1.join)(name), dest);
                        resolve();
                    }
                }
            }));
        });
    }
    /**
     * Create a readable stream of file at given path.
     * @param path Path to file
     * @param options Optional {@link Stream.ReadableOptions *node:stream.ReadableOptions*} object to customize stream
     * @param fsOptions Optional settings for underlying fs stream.
     *
     * @returns Readable stream object of file
     */
    static readStream(path, options, fsOptions) {
        return StorageManager.fileStream(path, 'r', options, fsOptions);
    }
    /**
     * Create a writable stream of file at given path.
     * @param path Path to file
     * @param options Optional {@link Stream.WritableOptions *node:stream.WritableOptions*} object to customize stream
     * @param fsOptions Optional settings for underlying fs stream.
     *
     * @returns Writable stream object of file
     */
    static writeStream(path, options, fsOptions) {
        return StorageManager.fileStream(path, 'w', options, fsOptions);
    }
    /**
     * Create a Duplex (both Readable and Writable) stream of file at given path.
     * @param path Path to file
     * @param options Optional {@link Stream.DuplexOptions *node:stream.DuplexOptions*} object to customize stream
     * @param fsOptions Optional settings for underlying fs stream.
     *
     * @returns Duplex stream object of file
     */
    static duplexStream(path, options, readOptions, writeOptions) {
        return StorageManager.fileStream(path, 'rw', options, {
            readOptions,
            writeOptions,
        });
    }
    static fileStream(path, mode = "rw", options = {}, fsOptions = {}) {
        var _a, _b;
        options = options !== null && options !== void 0 ? options : {};
        fsOptions = fsOptions !== null && fsOptions !== void 0 ? fsOptions : {};
        switch (mode !== null && mode !== void 0 ? mode : "rw") {
            case "r":
                return fs_1.default.createReadStream(path, Object.assign(Object.assign({}, options), fsOptions));
                break;
            case "w":
                return fs_1.default.createWriteStream(path, Object.assign(Object.assign({}, options), fsOptions));
                break;
            case "rw":
                const [r, w] = [
                    fs_1.default.createReadStream(path, Object.assign(Object.assign({}, options), (_a = fsOptions) === null || _a === void 0 ? void 0 : _a.readOptions)),
                    fs_1.default.createWriteStream(path, Object.assign(Object.assign({}, options), (_b = fsOptions) === null || _b === void 0 ? void 0 : _b.writeOptions))
                ];
                const streamOptions = {
                    read: r.read.bind(r),
                    write: w.write.bind(w),
                };
                for (const [key, value] of Object.entries(options))
                    streamOptions[key] = value;
                const stream = new stream_1.default.Duplex(streamOptions);
                return stream;
                break;
            default:
                throw new Error("Invalid file stream mode!");
        }
    }
    static exists(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            let last = args.pop();
            let mode;
            let paths = Array.from(args).filter((arg) => typeof arg === "string");
            if (typeof last === "number")
                mode = last;
            else
                mode = fs_1.default.constants.F_OK;
            if (typeof last === "string")
                paths.push(last);
            return utils_1.LogicGates.AND(...yield Promise.all(paths.map(path => StorageManager._exists(path, mode))));
        });
    }
    /**
     * Wrapper to check if a path already exists in filesystem.
     * @param path Path to check avaiability.
     *
     * @returns A promise of existance check.
     */
    static _exists(path, mode = fs_1.default.constants.F_OK) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => fs_1.default.access(path, mode, err => resolve(!err)));
        });
    }
    /**
     * Wrapper to retrieve stats of a given path
     * @param path Path to retrieve stats.
     * @since 1.4.0
     */
    static stats(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (yield StorageManager.exists(path)) {
                    fs_1.default.lstat(path, (err, stats) => {
                        if (err)
                            reject(err);
                        else
                            resolve(stats);
                    });
                }
                else {
                    const err = Object.assign({}, new Error);
                    err.code = 'ENOENT';
                    err.errno = os_1.default.constants.errno.ENOENT;
                    err.path = path;
                    Error.captureStackTrace(err);
                    reject(err);
                }
            }));
        });
    }
    static doesntExist(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            return !(yield StorageManager.exists(...args));
        });
    }
    /** Checks if given path corresponds to a file */
    static isFile(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (yield StorageManager.exists(path))
                    fs_1.default.lstat(path, (err, stats) => {
                        if (!!err)
                            reject(err);
                        resolve(stats.isFile());
                    });
                else
                    resolve(false);
            }));
        });
    }
    /** Checks if given path corresponds to a directory */
    static isDirectory(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (yield StorageManager.exists(path))
                    fs_1.default.lstat(path, (err, stats) => {
                        if (!!err)
                            reject(err);
                        resolve(stats.isDirectory());
                    });
                else
                    resolve(false);
            }));
        });
    }
    static listDirectory(path, recursive = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((_return, _throw) => __awaiter(this, void 0, void 0, function* () {
                if (yield StorageManager.doesntExist(path))
                    _return([]);
                else if (yield StorageManager.isFile(path))
                    _return([path]);
                else if (!!recursive) {
                    fs_1.default.readdir(path, (err, list) => __awaiter(this, void 0, void 0, function* () {
                        if (!!err)
                            _throw(err);
                        else {
                            const statsPromises = list
                                .map(node => [node, (0, path_1.join)(path, node)])
                                .map(([node, _]) => __awaiter(this, void 0, void 0, function* () { return [node, yield StorageManager.stats(_)]; }));
                            const stats = yield Promise.all(statsPromises);
                            const directories = stats.filter(([, stats]) => stats.isDirectory())
                                .map(([_]) => [_, (0, path_1.join)(path, _)]);
                            const files = stats.filter(([, stats]) => stats.isFile())
                                .map(([_]) => [_, (0, path_1.join)(path, _)]);
                            const chainPromise = directories.map(([, fullpath]) => StorageManager.listDirectory(fullpath, true));
                            const chain = yield Promise.all(chainPromise);
                            _return(new DirectoryList_1.DirectoryList(path, [...chain, ...files.map(([_]) => _)], yield StorageManager.stats(path)));
                        }
                    }));
                }
                else {
                    fs_1.default.readdir(path, (err, list) => __awaiter(this, void 0, void 0, function* () {
                        if (!!err)
                            _throw(err);
                        else {
                            _return(list);
                        }
                    }));
                }
            }));
        });
    }
    /**
     * Wrapper to check if a path already exists in filesystem.
     * @param path Path to check avaiability.
     * @param cb Optional callback to run after async check.
     * @returns A promise of existance check.
     *
     * @deprecated @see {@link StorageManager.exists StorageManager.exists()}
     */
    static checkExist(path, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => fs_1.default.access(path, fs_1.default.constants.F_OK, err => {
                !!err ? reject(cb ? cb(false) : err) : resolve(cb ? cb(true) : true);
            }));
        });
    }
    /**
     * Wrapper to write files asynchronously in filesystem.
     * @param filePath Path of the file to write in filesystem (overrides if already exists).
     * @param f File data, as ArrayBuffer or UInt8Array.
     * @param encoding Optional encoding of data, default binary.
     *
     * @deprecated @see {@link StorageManager.put StorageManager.put()},
     *  {@link StorageManager.putStreamed StorageManager.putStreamed()},
     *  {@link StorageManager.append StorageManager.append()},
     *  {@link StorageManager.appendStreamed StorageManager.appendStreamed()},
     */
    static writeStorage(filePath, f, encoding = "binary") {
        return __awaiter(this, void 0, void 0, function* () {
            let buffer = Buffer.from(f);
            // removeLastElement(filePath.split("/"))
            fs_1.default.access((0, utils_1.removeLastElement)(filePath.split("/")).join("/"), fs_1.default.constants.F_OK, err => {
                if (err) {
                    fs_1.default.mkdir((0, utils_1.removeLastElement)(filePath.split("/")).join("/"), { recursive: true }, (err, _path) => {
                        if (err) {
                            if (err.code !== 'EEXIST')
                                console.error(err);
                            else
                                fs_1.default.createWriteStream(filePath).write(buffer, encoding);
                        }
                        else
                            fs_1.default.createWriteStream(filePath).write(buffer, encoding);
                    });
                }
                else
                    (0, utils_1.removeLastElement)(filePath.split("/")).join("/");
            });
            // return fs.createWriteStream(filePath).write(buffer, encoding);
        });
    }
    /**
     * Wrapper function to directory creation in filesystem (recursive or not).
     * @param path Path to search in filesystem.
     * @param options Filesystem options for mkdir operation.
     * @param cb Optional callback for mkdir async operation.
     * @returns A promise of mkdir operation.
     */
    static mkdir(path, options = { recursive: true }, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const promiseArgs = (first, ...args) => cb ? cb(first, ...args) : first;
                const preHandler = (err, path) => {
                    if (!!err) {
                        if (err.code !== 'EEXIST')
                            return reject(promiseArgs(err, path));
                        else
                            return resolve(promiseArgs(err, path));
                    }
                    else
                        return resolve(promiseArgs(null, path));
                };
                StorageManager.checkExist(path)
                    .then(() => __awaiter(this, void 0, void 0, function* () { return preHandler(null, path); }), () => __awaiter(this, void 0, void 0, function* () {
                    if ((0, semver_1.lt)(process.versions.node, "10.12.0")) {
                        return path.split("/")
                            .map((v, i, arr) => fs_1.default.mkdir(path.split(v)[0].concat(v), options, (err) => {
                            if (arr.length - 1 > i) {
                                if (err && err.code !== 'EEXIST') {
                                    console.error(err);
                                    preHandler(err);
                                }
                            }
                            else
                                preHandler(err);
                        }));
                    }
                    else
                        return fs_1.default.mkdir(path, options, preHandler);
                }));
            });
        });
    }
    /**
     *
     * @param filePath File path to write in filesystem (if parent directory does not exist, create before write the file).
     * @param data File data as ArrayBuffer.
     * @param chunkSize Chunk size of file.
     * @param cb Optional callback called when write operation is finished.
     * @returns A promise of the write operation.
     *
     * @deprecated @see {@link StorageManager.writeStream StorageManager.writeStream()}
     */
    static writeFileStream(filePath, data, chunkSize = 65536, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const parentPath = (0, utils_1.removeLastElement)(filePath.split("/")).join("/");
                StorageManager.mkdir(parentPath, { recursive: true }).then(_ => {
                    const wstream = fs_1.default.createWriteStream(filePath);
                    wstream.on("error", cb !== null && cb !== void 0 ? cb : reject);
                    for (let c = 0; c < data.byteLength; c += chunkSize) {
                        const buffer = Buffer.from(data.slice(c, c + chunkSize));
                        wstream.write(buffer, cb !== null && cb !== void 0 ? cb : (err => {
                            if (err) {
                                wstream.end();
                                reject(err);
                            }
                        }));
                    }
                    wstream.end(cb);
                    resolve(true);
                }, reject);
            });
        });
    }
    /**
     * Reads given file asynchronously on-demand and pipe out to given writable stream
     * @deprecated Obsolete and unsafe code using `Stream.pipe(stream: Stream.Writable)`. Prefer `Stream.pipeline(...streams: Stream[, cb: err => void])` implementation at `StorageManager.readFileStream(...)`
     * @param filePath path to the file in default storage
     * @param out writable stream to output retrieved data
     *
     * @deprecated @see {@link StorageManager.readStream StorageManager.readStream()}
     */
    static readStorage(filePath, out) {
        return __awaiter(this, void 0, void 0, function* () {
            let file = fs_1.default.createReadStream(filePath);
            file.on('open', () => file.pipe(out));
            file.on('error', err => out.end(err));
        });
    }
    /**
     * Assynchronously reads given file at default storage. Supports Callback syntax and Promise syntax.
     * @param filePath path to the file in default storage.
     * @param cb optional callback to handle output and error. If not provided it resolve as a Promise
     *
     * @deprecated @see {@link StorageManager.getAsBuffers StorageManager.getAsBuffers()}
     */
    static getFileContents(filePath, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let arr_buffer = new Array();
                /* const wstream =  */ StorageManager.readFileStream(filePath, {
                    write: (chunk, _encoding, next) => {
                        arr_buffer.push(chunk);
                        next();
                    }
                }, cb !== null && cb !== void 0 ? cb : ((err) => err ? reject(err) : resolve(arr_buffer)));
                // wstream.on('close', () => cb? cb(null, arr_buffer) : resolve(arr_buffer))
            });
        });
    }
    /**
     * Creates an Writable stream to transform/process chunk data from a file, piping'em, and returns the writed stream.
     *
     * @deprecated @see {@link StorageManager.readStream StorageManager.readStream()}
     *
     * @param filePath path to the file in default storage.
     * @param opts options to setup the write stream.
     * @param cb optional callback to error handling (default `console.error` output stream).
     */
    static readFileStream(filePath, opts, cb) {
        var _a;
        const f = fs_1.default.createReadStream(filePath);
        const tstream = !!((_a = opts) === null || _a === void 0 ? void 0 : _a.writable) ? opts : new stream_1.default.Writable(opts);
        f.on('error', err => {
            tstream.end();
            cb ? cb(err) : console.error(err);
        });
        f.on('close', () => tstream.end());
        stream_1.default.pipeline(f, tstream, cb !== null && cb !== void 0 ? cb : (err => !!err ? console.error : null));
        return tstream;
    }
    /**
     * Wrapper of delete operation in filesystem.
     * @param filePath A path to unlink or delete from filesystem.
     * @param callback Optional callback called after delete operation is finished.
     * @returns A promise of the delete operation.
     */
    static deleteFromStorage(filePath, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const metadata = yield StorageManager.stats(filePath);
                if (metadata.isFile() || metadata.isSymbolicLink())
                    fs_1.default.unlink(filePath, callback !== null && callback !== void 0 ? callback : (err => err ? reject(err) : resolve()));
                else if (metadata.isDirectory()) {
                    if ((0, semver_1.lt)(process.versions.node, "12.10.0 ")) {
                        const dir = yield StorageManager.listDirectory(filePath, true);
                        const files = Array.from(dir)
                            .filter((file) => typeof file === "string");
                        const innerDirs = Array.from(dir)
                            .filter((file) => file instanceof DirectoryList_1.DirectoryList);
                        for (const file of files)
                            yield StorageManager.deleteFromStorage(file);
                        for (const { name } of innerDirs)
                            yield StorageManager.deleteFromStorage(name);
                        fs_1.default.rmdir(filePath, callback !== null && callback !== void 0 ? callback : (err => err ? reject(err) : resolve()));
                    }
                    else {
                        fs_1.default.rmdir(filePath, { recursive: true }, callback !== null && callback !== void 0 ? callback : (err => err ? reject(err) : resolve()));
                    }
                }
            }));
        });
    }
    /**
     * Wrapper for opening attempts to a path, be file or directory.
     * @param path Path to open a file or list directory.
     * @param ifFile Optional callback called if path leads to a file.
     * @param ifDir Optional callback called if path leads to a directory.
     * @param encoding Optional encoding for files, default utf-8.
     *
     * @deprecated @see {@link StorageManager.stats StorageManager.stats()}
     */
    static openFileOrDirectory(path, ifFile, ifDir, encoding = "utf-8") {
        return __awaiter(this, void 0, void 0, function* () {
            fs_1.default.access(path, fs_1.default.constants.F_OK | fs_1.default.constants.R_OK, (err) => {
                if (err)
                    throw ({ message: "no such file or directory!", path: path });
                else
                    fs_1.default.lstat(path, (err, stats) => {
                        if (err) {
                            console.log(err);
                            throw err;
                        }
                        else if (stats.isFile())
                            fs_1.default.readFile(path, { encoding }, (ifFile !== null && ifFile !== void 0 ? ifFile : (() => null)));
                        else if (stats.isDirectory())
                            fs_1.default.readdir(path, (ifDir !== null && ifDir !== void 0 ? ifDir : (() => null)));
                        else
                            throw ({ message: `operation not supported! (${path})` });
                    });
            });
        });
    }
}
exports.StorageManager = StorageManager;
StorageManager.constants = fs_1.default.constants;
StorageManager.path = path_1.default;
StorageManager.stream = StorageManager.fileStream;
/**
 * Wrapper of delete operation in filesystem.
 * @param filePath A path to unlink or delete from filesystem.
 * @returns A promise of the delete operation.
 */
StorageManager.delete = StorageManager.deleteFromStorage;
exports.default = StorageManager;
