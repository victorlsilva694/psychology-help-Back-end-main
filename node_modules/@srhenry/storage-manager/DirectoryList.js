"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Directory = exports.DirectoryList = void 0;
const path_1 = require("path");
/**
 * Wrapper for directory structure in filesystem. May be recursive
 */
class DirectoryList {
    constructor(arg1, struct = [], stats) {
        if (typeof arg1 === 'string') {
            this.name = arg1;
            this.struct = struct;
            this._stats = stats;
        }
        else if (arg1 instanceof DirectoryList) {
            this.name = arg1.name;
            this.struct = arg1.struct;
            this._stats = arg1.stats;
        }
        else {
            this.name = "/";
            this.struct = [];
        }
    }
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
    }
    /**
     * Stats info of directory.
     * @see {@link Stats NodeJS.fs.Stats}
     */
    get stats() {
        return this._stats;
    }
    *[Symbol.iterator]() {
        for (const item of this.struct)
            yield item;
    }
    [Symbol.toPrimitive](hint) {
        switch (hint) {
            case 'string':
                return this.__toString();
        }
    }
    __toString(deep = 0, traceChar = " ", padUnit = 4) {
        const directoriesFirst = this.struct.sort((a, b) => a instanceof DirectoryList ? (b instanceof DirectoryList ? 0 : -1) : (b instanceof DirectoryList ? 1 : 0));
        let str = `DirectoryList: ${deep > 0 ? (0, path_1.basename)(this.name) : this.name} {\n`;
        str = str.padStart(str.length + (deep * padUnit), traceChar);
        for (const row of directoriesFirst) {
            if (row instanceof DirectoryList)
                str += row.__toString(deep + 1, traceChar, padUnit);
            else {
                let out = `File: ${row}\n`;
                str += out.padStart(out.length + ((deep + 1) * padUnit), traceChar);
            }
        }
        let tail = "}\n";
        tail = tail.padStart(tail.length + (deep * padUnit), traceChar);
        return str.concat(tail);
    }
    toString() {
        return `${this}`;
    }
    /** Get JSON representation of inner directory structure on filesystem */
    get(fullname = false) {
        return this.struct.map(item => {
            if (item instanceof DirectoryList)
                return item.toJSON(fullname, false);
            else
                return item;
        });
    }
    /**
     * Prefered method to serialize instance
     * @since 1.3.0
     */
    toJSON(fullname = false, root = true) {
        return {
            [(root || fullname) ? this.name : (0, path_1.basename)(this.name)]: this.get(fullname)
        };
    }
}
exports.DirectoryList = DirectoryList;
/** Alias for {@link DirectoryList} */
exports.Directory = DirectoryList;
exports.default = DirectoryList;
